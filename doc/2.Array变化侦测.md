## 拦截器 ##
```
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto);
[
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
].forEach(function(method) {
    // 缓存原始方法
    const  original = arrayProto[method]
    Object.defineProperty(arrayMethods, method, {
        value: function mutator(...args) {
            return original.apply(this, args)
        },
        enumerable: false,
        writable: true,
        configurable: true,
    })
})
```

说明：
1. 👆👆👆代码中，创建了变量arrayMethods，继承自Array.prototype,具备所有的功能，
2. 在arrayMethods上使用Object.defineProperty方法将那些可以改变数组自身内容的方法（push、pop、shift、unshift、splice、sort和reverse）进行封装
3. 当使用push，其实调用arrayMethods.push，执行内部的mutator函数，在mutator内部执行original也就是Array.prototype.push的功能
4. 这样我们就可以在mutator中做一些其他的事，比如说发送变化通知

有了拦截器，想要让他生效，就需要去覆盖Array.prototype，但又不能直接覆盖，污染全局的Array，我们希望拦截操作只针对被侦测变化的数据生效，也就是说只覆盖那些响应式数组的原型

将一个数据转换成响应式，需要通过Observer，只需要在Observer中使用拦截器覆盖那些即将被转换成响应式Array类型数据的原型就好了
```
export class Observer {
    constructor (value) {
        this.value = value;

        if (Array.isArray(value)) {
            value.__proto__ = arrayMethods // new add
        } else {
            this.walk(value);
        }
    }
}
```

## 将拦截器方法挂载到数组属性上 ##
``````
import { arrayMethods } from './array';

// __proto__是否可用
const hasProto = '__proto__' in {};
const arrayKeys = Object.getOwnPropertyNames(arrayMethods);

export class Observer {
    constructor(value) {
        this.value = value;

        if (Array.isArray(value)) {
            //update
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys); // new add
        } else {
            this.walk(value);
        }
    },

     /**
     * 
     * walk会将每一个属性都转换成getter/setter的形式来侦测变化
     * 这个方法只有在数据类型为object时被调用
     */
    walk (obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]]);
        }
    }
}

function protoAugment(target, src, keys) {
    target.__proto__ = src;
}

function copyAugment(target, src, keys) {
    for(let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        def(target, key, src[key]); // 工具函数
    }
}
``````
对于浏览器不支持通过__proto__添加的，直接将arrayMethods身上的方法设置到被侦测的数组上，当用户使用这些方法的时候，其实执行的不是浏览器原生Array.prototype上的方法，而是拦截器提供的方法，因为当访问一个对象的方法时，只有其自身不存在这个方法，才会去使用原型上的方法。

## 如何收集依赖 ##
创建拦截器，本质上是为了得到一种能力，当数组内容发生变化时得到通知的能力，现在具备这种能力，但是缺少通知的对象，需要收集依赖。其实不管value是什么，要想在一个object中得到某个属性的数据，肯定要通过key来读取value，比如👇👇👇读取list，先触发名叫list属性的getter，this.list调用
```
{
    list: [1,2,3,4,5]
}
```

```
function defineReactive(data, key, val) {
    if (typeof val === 'object') new Observer(val);
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend(); // 收集依赖
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            dep.notify();
            this.val = newVal;
        }
    })
}
```
## 依赖列表存在哪儿 ##
```
export class Observer {
    constructor(value) {
        this.value = value;
        this.dep = new Dep() // 新增Dep

        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
        } else {
            this.walk(value);
        }
    }
}
```
数组在getter中收集依赖，在拦截器中触发依赖，所以依赖的保存位置需要保证getter和拦截器都可以访问到
## 收集依赖 ##
```
function defineReactive(data, key, val) {
    let childOb = observer(val); // new add
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend(); // 收集依赖
            
            if (childOb) { // new add
                childOb.dep.depend();
            }
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            dep.notify();
            val = newVal;
        }
    })
}
/**
* 尝试为value创建一个Observer实例
* 如果创建成功，直接返回新创建的Observer实例， 如果value已经存在一个Observer实例，直接返回
*/
export function observe(value, asRootData) {
    if (!isObject(value)) {
        return;
    }
    let ob;
    if (hasOwn(value, '__ob__)' && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
    } else {
        ob = new Observer(value)
    }
    return ob;
}
```

## 在拦截器中获取Observer实例

```
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true,
    })
}

export class Observer {
    constructor(value) {
        this.value = value;
        this.dep = new Dep();
        def(value, '__ob__', this);  // new add

        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
        } else {
            this.walk(value);
        }
    }
}
```
## 总结 ##
Array追踪变化的方式和Object不一样，因为它是通过方法来改变内容的，所以我们创造拦截器去覆盖数组原型的方式来追踪变化，

```
// 1.拦截器 
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto);
[
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
].forEach(function(method) {
    // 缓存原始方法
    const  original = arrayProto[method]
    Object.defineProperty(arrayMethods, method, {
        value: function mutator(...args) { // 拦截原型上的方法
            return original.apply(this, args)
        },
        enumerable: false,
        writable: true,
        configurable: true,
    })
})

export class Observer {
    constructor (value) {
        this.value = value;

        if (Array.isArray(value)) {
            value.__proto__ = arrayMethods // 使拦截器生效
        } else {
            this.walk(value);
        }
    }
}

// 2.为了不污染全局Array.prototype，我们在observer中针对那些需要侦测变化的数组使用__proto__来覆盖原型方法，针对不支持这种方式的浏览器，直接循环拦截器，把方法直接设置到数组身上来拦截原生方法。

const hasProto = '__proto__' in {}; // __proto__是否可用
const arrayKeys = Object.getOwnPropertyNames(arrayMethods);

export class Observer {
    constructor(value) {
        this.value = value;

        if (Array.isArray(value)) {
            //update
            const augment = hasProto ? protoAugment : copyAugment; // 兼容不支持__proto__的浏览器
            augment(value, arrayMethods, arrayKeys); // new add
        } else {
            this.walk(value);
        }
    },

     /**
     * 
     * walk会将每一个属性都转换成getter/setter的形式来侦测变化
     * 这个方法只有在数据类型为object时被调用
     */
    walk (obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]]);
        }
    }
}

function protoAugment(target, src, keys) {
    target.__proto__ = src;
}

function copyAugment(target, src, keys) {
    for(let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        def(target, key, src[key]); // 工具函数
    }
}

function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true,
    })
}

// 3. Array收集依赖的方式和Object一样，都是在getter中收集，但是由于使用依赖的位置不同，数组需要在拦截器中向依赖发送消息，所以依赖不能想Object一样保存在defineReactive中，而是保存在Observer实例上
Array在getter中收集依赖，在拦截器中触发依赖
function defineReactive(data, key, val) {
    if (typeof val === 'object') new Observer(val);
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend(); // 收集依赖
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            dep.notify();
            this.val = newVal;
        }
    })
}
// 知道如何收集依赖后，需要存放依赖列表，为啥放在Observer中是因为我们要让拦截器和getter都能访问到这个依赖
export class Observer {
    constructor(value) {
        this.value = value;
        this.dep = new Dep() // 新增Dep

        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
        } else {
            this.walk(value);
        }
    }
}
==================================================
// 在getter中访问并收集依赖
function defineReactive(data, key, val) {
    let childOb = observer(val); // new add
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend(); // 收集依赖
            
            if (childOb) { // new add
                childOb.dep.depend();
            }
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            dep.notify();
            val = newVal;
        }
    })
}
/**
* 尝试为value创建一个Observer实例
* 如果创建成功，直接返回新创建的Observer实例， 如果value已经存在一个Observer实例，直接返回
*/
export function observe(value, asRootData) {
    if (!isObject(value)) {
        return;
    }
    let ob;
    if (hasOwn(value, '__ob__)' && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
    } else {
        ob = new Observer(value)
    }
    return ob;
}

export class Observer {
    constructor(value) {
        this.value = value;
        this.dep = new Dep();
        def(value, '__ob__', this);  // new add

        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
        } else {
            this.walk(value);
        }
    }
}
// 4. 在Observer中，我们对每一个侦测le变化的数据都标上__ob__，并把this（Observer实例）保存在__ob__上，这样就可以通过数据的__ob__属性拿到Observer实例了，主要是为了一标记数据是否被侦测变化，二是可以很方便地通过数据取到__ob__，从而拿到Observer实例上保存的依赖，当拦截到数组发生变化时，向依赖发送通知。
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true,
    })
}

export class Observer {
    constructor(value) {
        this.value = value;
        this.dep = new Dep();
        def(value, '__ob__', this);  // new add

        if (Array.isArray(value)) {
            const augment = hasProto ? protoAugment : copyAugment;
            augment(value, arrayMethods, arrayKeys);
        } else {
            this.walk(value);
        }
    }
}

[
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
].forEach(function(method) {
    // 缓存原始方法
    const  original = arrayProto[method]
    Object.defineProperty(arrayMethods, method, {
        value: function mutator(...args) {
            const ob = this.__ob__;  // 通过this.__ob__获取Observer实例
            return original.apply(this, args)
        },
        enumerable: false,
        writable: true,
        configurable: true,
    })
})
// 调用ob.dep.notify()去通知依赖数据发生改变
[
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
].forEach(function(method) {
    // 缓存原始方法
    const  original = arrayProto[method]

    def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;  // 通过this.__ob__获取Observer实例
        ob.dep.notify();
        return result;
    })
})
// 5. 除了侦测数组自身的变化外，数组中元素发生变化也要侦测，在Observer中判断如果当前被侦测的数据是数组，则调用observerArray方法将数组中的每一个元素都转换成响应式并侦测变化
export class Observer {
    constructor(value) {
        this.value = value;
        def(value, '__ob__', this);

        // new add
        if(Array.isArray(value)) {
            this.ObserverArray(value);
        } else {
            this.walk(value);
        }
    }
}
/**
 * 侦测数组中的每一项
 */
ObserverArray(items) {
    for (let i = 0, l = items.length; i < l; i++) {
        observe(items[i])
    }
}
// 6.除了侦测已有的数据外，当用户使用push等方法向数据中新增数据时，新增数据也要进行变化侦测。如果是push，unshift、和splice方法，则从参数中将新增的数据提取出来，然后使用observeArray对新增数据进行变化侦测
[
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
].forEach(function(method) {
    // 缓存原始方法
    const  original = arrayProto[method]

    def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;  // 通过this.__ob__获取Observer实例
        let inserted;
        switch(method) {
            case 'push':
            case 'unshift':
                inserted = args; // 提取元素
                break;
            case 'splice':
                inserted = args.slice(2)
                break;
        }
        if (inserted) ob.ObserverArray(inserted); //侦测新增元素
        ob.dep.notify();
        return result;
    })
})
```
对于数组类型数据，只能拦截原型上的方法，而无法拦截数组特有的语法，如length