### 变化侦测 ###
渲染：从状态生DOM，再输出到用户界面显示的一整套流程
vue最独特的特性之一就是响应式系统，通过侦测数据模型对象变化，通知视图进行更新，使得状态管理非常简单、直接。

vue.js的渲染过程是声明式的，通过模版来描述状态与DOM之间的映射关系。

## 为什么要引入虚拟DOM？##
vue.js的变化侦测属于推，进行更细粒度更新。假如一个状态绑定很多依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，会向这个状态的所有依赖发送通知，让它们进行更新DOM。当然，因为粒度更细，每个状态绑定的依赖越多，依赖追踪在内存上的开销也就会越大。因此在2.0中引入虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是组件，这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对，大大降低依赖数量，从而降低依赖追踪所消耗的内存。

## 如何追踪变化 ##
JS中侦测变化可以使用Object.defineProperty和ES6的Proxy，2.0使用前者，3.0使用Proxy
```
function defineReactive (data, key, val) {
    Object.defineProperty (data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            return val;
        },
        set: function (newVal) {
            if (val === newVal) {
                return;
            }
            val = newVal;
        }
    })
}
```
通过 difineReative 对Object.defineProperty进行封装，定义一个响应式数据，每当从data的key中读取数据，get函数被触发，往data的key中设置数据，set函数被触发。

## 如何收集依赖 ##
我们之所以要观察数据，其目的是当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方
例如我们在模版中写入：
```
<template>
    <h1>{{name}}</h1>
</template>
```
在vue2.0中，模版使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。
因此我们需要把所有用到数据name的地方收集起来，然后等属性发生变化时，把之前收集的依赖循环触发一遍就好了。
总结：在getter中收集依赖，在setter中触发依赖
```
function defineReactive (data, key, val) {
    let dep = []; // 新增，存储当前key的依赖
    Object.defineProperty (data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            dep.push(window.target) // add
            return val;
        },
        set: function (newVal) {
            if (val === newVal) {
                return;
            }
            // add
            for (let i = 0; i < dep.length; i++) {
                dep[i](newVal, val)
            }
            val = newVal;
        }
    })
}
```
假设依赖是一个函数，保存在window.target上，我们通过新增数组dep，存储被收集的依赖，然后在set被触发时，循环dep以触发收集到的依赖。但👆的写法有点耦合，我们将依赖收集的代码封装成一个Dep类，专门帮助我们管理依赖，通过这个类，可以收集依赖，删除依赖或者向依赖发送通知。👇👇我们将依赖收集到Dep中
```
export default class Dep {
    constructor () {
        this.subs = []
    }

    addSub (sub) {
        this.subs.push(sub)
    }

    removeSub (sub) {
        remove (this.subs, sub)
    }

    depend () {
        if (window.target) {
            this.addSub(window.target)
        }
    }

    notify () {
        const subs = this.subs.slice()
        for (let i = 0, l = subs.length; i < l; i++) {
            subs[i].update()
        }
    }
}

function remove (arr, item) {
    if (arr.length) {
        const index = arr.indexOf(item)
        if (index > -1) {
            return arr.splice(index, 1)
        }
    }
}

function defineReactive (data, key, val) {
    let dep = new Dep(); // update
    Object.defineProperty (data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            dep.depend() // update
            return val;
        },
        set: function (newVal) {
            if (val === newVal) {
                return;
            }
            val = newVal;
            dep.notify() // update
        }
    })
}
```
## 依赖是谁 ##

当属性发生变化后，应该通知谁，使用数据的地方有很多，而且类型还不一样，既有可能是模版，也可能是用户写的一个watch，需要抽象出一个能集中处理这些情况的类，然后，我们在依赖收集阶段只收集这个封装好的类的实例，通知也只通知它一个，然后它再负责通知其他。

定义一个Watcher作为中介传递消息

首先看一下watch的常用方式：
```
vm.$watch('a.b.c', function (newVal, oldVal) {
    // todo
})
```
这段代码表示当data.a.b.c属性变化时，执行第二个参数中的函数
可以看到只要把这个watch实例添加到data.a.b.c属性的Dep中就行，当属性值改变，通知watcher
```
export default class Watcher {
    constructor (vm, expOrFn, cb) {
        this.vm = vm
        this.getter = parsePath(expOrFn)
        this.cb = cb
        this.value = this.get();
    }

    get () {
        window.target = this
        let value = this.getter.call(this.vm, this.vm) // 为什么是两个this.vm，因为要获取vm上的参数，得获取到vm的环境
        window.target = undefined
        return value
    }

    update () {
        const oldValue = this.value
        this.value = this.get()
        this.cb.call(this.vm, this.value, oldValue)
    }
}
/**
 * 解析简单路径
 */
const bailRE = /[^\w.$]/
export function parsePath (path) {
    if (bailRE.test(path)) {
        return
    }
    const segments = path.split('.')
    return function (obj) {
        for (let i = 0; i < segments.length; i++) {
            if (!obj) return;
            obj = obj[segments[i]] // a.b.c将a，b，c都作为依赖收集
        }
        return obj
    }
}
```
在get方法中把window.target设置成this，也就是当前watcher实例，然后读取data.a.b.c的值，触发getter，触发收集依赖的逻辑，会从window.taregt中读取一个依赖并添加到Dep中，依赖注入到Dep中后，每当data.a.b.c的值发生变化，就会让依赖列表中所有依赖循环触发update方法

上述代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性都侦测到，所以要封装成一个Observer类，将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，去追踪它们的变化。

## 递归侦测所有的key ##
```
/**
 * Observer类会附加到每一个被侦测的object上，
 * 一旦被附加上，Observer会将object的所有属性转换成getter/setter的形式来收集属性的依赖
 * 并且当属性发生变化时会通知这些依赖
 */
export class Observer {
    constructor (value) {
        this.value = value;

        if (!Array.isArray(value)) {
            this.walk(value);
        }
    }
    /**
     * 
     * walk会将每一个属性都转换成getter/setter的形式来侦测变化
     * 这个方法只有在数据类型为object时被调用
     */
    walk (obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]]);
        }
    }
}

function defineReactive(data, key, val) {
    if (typeof val === 'object') {
        new Observer(val);
    }
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            dep.depend();
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return;
            }
            val = newVal;
            dep.notify();
        }
    })
}
```
## 关于Object的问题 ##
前面介绍了Object类型数据变化侦测的原理，了解了数据的变化是通过getter/setter来追踪的，但有些语法即便数据发生变化，vue.js也追踪不到
比如新增属性
```
var vm = new Vue({
    el: '#el',
    template: '#demo-template',
    data: {
        obj: {},
    },
    methods: {
        action() {
            this.obj.name = 'brewin';
        }
    }
})
或者删除属性
var vm = new Vue({
    el: '#el',
    template: '#demo-template',
    data: {
        obj: {
            name: 'brewin',
        },
    },
    methods: {
        action() {
            delete this.obj.name;
        }
    }
})
```
vue通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，为了解决这个问题，提供了两个API-vm.$set和vm.$delete方法。

## 总结 ##
变化侦测就是侦测数据的变化，当数据发生变化时，要能侦测并发出通知
1. Object可以通过Object.defineProperty将属性转换成getter/setter的形式来追踪变化，读取数据触发getter，修改数据触发setter
2. 在getter中收集有那些依赖使用了数据，当setter被触发时，去通知getter中收集的依赖数据变化
3. 收集依赖需要建立一个数组Dep来存储
4. 所谓的依赖，就是Watcher，只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，拿个Watcher就被收集到Dep中，当数据发生变化，会循环依赖列表，把所有的Watcher都通知一遍
5. Watcher的原理是先把自己设置成全局唯一的指定位置（比如window.target），然后读取数据，触发getter，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中，通过这种方式，Watcher可以主动订阅任意一个数据的变化
6. 为了侦测到object中所有数据的变化，创建了Observer🥱，将objetc中的所有数据递归转换成响应式的。